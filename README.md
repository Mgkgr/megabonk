# Megabonk RL Bot

Набор скриптов для обучения и запуска RL-бота в игре Megabonk на базе Gymnasium + Stable-Baselines3. Проект умеет захватывать окно игры, формировать наблюдения (стек из 4 кадров 84×84 в оттенках серого) и отдавать управление агенту или простому автопилоту. Скрипты:

- `train.py` — запускает обучение PPO на среде `MegabonkEnv` и сохраняет модель в `megabonk_ppo_cnn`.
- `play.py` — загружает обученную модель и выполняет инференс (игра «вживую»).
- `megabonk_env.py` — Gymnasium-окружение с захватом экрана, управлением через `pydirectinput` и наградами за «выживание».
- `autopilot.py` — автопилот на шаблонах и простых эвристиках для меню/смерти/выбора персонажа и частично для движения в рантайме.

## Требования и зависимости

Минимальная среда:

- Windows (управление через `pydirectinput` и захват окна через `mss`/`window_capture`).
- Python 3.10+.
- Зависимости Python:
  - `mss`
  - `opencv-python` (`cv2`)
  - `pydirectinput`
  - `gymnasium`
  - `stable-baselines3`
  - `torch`
  - `numpy`

Пример установки (вариант):

```bash
pip install mss opencv-python pydirectinput gymnasium stable-baselines3 torch numpy
```

> Важно: требуется запущенная игра и корректный заголовок окна. По умолчанию в `train.py`/`play.py` используется `WINDOW = "Megabonk"` — подстройте при необходимости.

## Подготовка шаблонов

Автопилот и детектор экранов используют шаблоны (template matching). Подготовка:

1. Сделайте скриншот окна и сохраните рядом с `make_templates.py` файл `screen.png`.
   Требования к `screen.png`:
   - полный кадр окна игры (без обрезки), с тем же разрешением/масштабом, на котором будет идти захват;
   - без постобработки/масштабирования (PNG без сжатия артефактами);
   - интерфейс в привычном состоянии (видны кнопки, заголовки, HUD/миникарта),
     чтобы можно было вырезать шаблоны для нужных экранов.
2. Запустите генератор шаблонов:

```bash
python make_templates.py
```

3. Выделите ROI мышью, задайте имя шаблона (например `tpl_play`).
4. Файлы сохраняются в папку `templates/` (создаётся автоматически).

### Автопилотные сценарии и необходимые шаблоны

Автопилот использует набор базовых шаблонов. Ниже — рекомендуемый минимум:

- **Главное меню**: `tpl_play`
- **Выбор персонажа**: `tpl_char_select_title`, `tpl_fox_face`, `tpl_confirm`
- **Экран смерти**: `tpl_dead`, `tpl_confirm`
- **Экран разблокировок/оружия**: `tpl_unlocks_title`
- **Выбор оружия из сундука**: `tpl_katana`, `tpl_dexec`
- **Выбор фолиантов/книг**: `tpl_foliant_bottom1`, `tpl_foliant_bottom2`,
  `tpl_foliant_bottom3`, `tpl_blood_tome`
- **Рантайм (HUD/миникарта)**: `tpl_lvl`, `tpl_minimap`

Если часть шаблонов отсутствует, автопилот просто пропустит соответствующий сценарий,
но для стабильной работы рекомендуется собрать весь список.

## Примеры запуска

Обучение:

```bash
python train.py
```

Инференс (игра с обученной моделью):

```bash
python play.py
```

## Реализованные функции

- Захват изображения окна игры и преобразование в наблюдение 84×84×4 (grayscale stack).
- Экшн-пространство для движения, прыжка и слайда (`MultiDiscrete`).
- Автопилот по шаблонам для:
  - детекции экранов (меню, выбор персонажа, смерть, рантайм);
  - кликов по кнопкам/подтверждениям;
  - выбора персонажа (пример — лиса).
- Эвристический автопилот (опционально) для движения по цветовым признакам.
- PPO-обучение через Stable-Baselines3.

## Сравнительная таблица автопилота (после PR 71–75)

| Компонент | Как сейчас после PR 71–75 | Почему болит | Что сделать в MVP (1–2 вечера) | Что улучшать дальше |
| --- | --- | --- | --- | --- |
| Захват окна (WindowCapture + DPI) | Захват client‑bbox через WinAPI + mss, DPI awareness включён | Если DPI не тот — ROI ломаются | Оставить как есть, проверить что `enable_dpi_awareness()` вызывается самым первым | Добавить авто‑проверку bbox + лог «реальный размер кадра» |
| Детектор смерти | Часто завязан на `_top_left_time_cells_black(84x84)` | Строгие пороги/не тот «патч» → пропуски или ложные | Комбинировать: быстрый чёрный‑экран + `is_death_like()` фолбэком + confirm‑template | Добавить state‑machine смерти (несколько кадров подряд) |
| Рестарт (hold R) | Есть удержание R | Может конфликтовать с залипшими клавишами/не тот экран | На смерти: `release_all_keys()` → `hold("r")` → `terminated=True` | Добавить «если через X секунд не RUNNING — нажать ещё раз / вернуть в меню» |
| HUD OCR (время/HP/голд) | pytesseract + препроцессинг | Медленно/нестабильно, ROI фиксят абсолютными px | Для MVP выключить или троттлить с кешем | Позже: отдельный поток OCR, авто‑калибровка ROI, reward shaping |
| Эвристический автопилот (HeuristicAutoPilot) | Уже есть (враг/лут/unstuck) | Может не применяться из‑за условий screen | Применять в RUNNING без сложной проверки, пока не стабилизируете screen‑детект | Переехать с HSV на комбинированный детектор (grid + контуры) |
| Управление камерой | `moveRel` или стрелки | В игре может не работать `moveRel` в некоторых режимах | Добавить флаг `use_arrow_cam=True` для проверки, а лучше — авто fallback | Позже: непрерывный yaw/pitch, не 3‑позиционный |
| Debug‑распознавание | Дамп PNG, логи раз в N секунд | Создаёт ощущение «видит раз в несколько секунд», может тормозить | На обучение — выключить полностью | Отдельный режим debug‑run с горячей клавишей |

## Текущие ограничения

- Проект рассчитан на Windows и управление активным окном игры (без headless/серверного режима).
- Детекция смерти и экранов — эвристики + шаблоны; возможны ложные срабатывания при других скинах/UI.
- Награда в окружении в основном отражает «выживание»; прогресс по XP/HP пока не реализован (в коде есть заготовки).
- Шаблоны и регионы привязаны к конкретному разрешению/масштабу окна; при изменении интерфейса требуется переснять шаблоны.
- Параметры автопилота/детекции и заголовок окна нужно подстраивать под локальную установку игры.
